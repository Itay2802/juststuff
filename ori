<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>××œ×š ×”×§×™×˜×•: ××¦×•×“ ×”×¤×©×˜×™×“×”</title>
<style>
  :root{ --w: 900px; --h: 600px; --shadow: rgba(0,0,0,.55); }
  *{box-sizing:border-box}
  body{
    margin:0;background:#111;color:#fff;font-family:system-ui, Arial, "Segoe UI", sans-serif;
    display:flex;align-items:center;justify-content:center;min-height:100vh;
  }
  .wrap{position:relative;width:var(--w);max-width:100vw}
  canvas{
    width:100%;height:calc(var(--h) * 1px);display:block;
    background:url('https://i.postimg.cc/TwG3CYtF/4.png') no-repeat center/cover;
    image-rendering: pixelated;
  }
  .overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,.45)}
  .card{width:min(92%,560px);background:rgba(20,20,20,.9);border:1px solid #2b2b2b;border-radius:20px;padding:22px 20px;box-shadow:0 10px 30px var(--shadow);text-align:center}
  h1{margin:8px 0 4px;font-size:clamp(22px,3.8vw,34px)}
  p{margin:8px 0 0;line-height:1.55}
  ul{margin:12px 0 0;text-align:right}
  .btn{margin-top:14px;cursor:pointer;border:0;border-radius:14px;padding:12px 18px;background:#2dd4bf;color:#001b18;font-weight:700;font-size:18px;box-shadow:0 6px 16px rgba(45,212,191,.35)}
  .hud{position:absolute;left:12px;top:10px;font-weight:700;text-shadow:0 2px 6px rgba(0,0,0,.6)}
</style>
</head>
<body>
  <div class="wrap" style="height:calc(var(--h) * 1px);">
    <canvas id="game" width="900" height="600"></canvas>
    <div class="hud" id="hud">× ×™×§×•×“: 0 Â· ×–××Ÿ: 40</div>
    <div class="overlay" id="startOverlay">
      <div class="card">
        <h1>××œ×š ×”×§×™×˜×•: ××¦×•×“ ×”×¤×©×˜×™×“×”</h1>
        <p>
          ×¢×›×©×™×• ×–×” ××™×©×™: <strong>× ×•×¤×œ×™× ×¨×§ ×××›×œ×™× ×œ×Ö¾×§×™×˜×•×’× ×™×™×</strong>. ××•×¨×™ ×¨×¥ ××¦×“ ×œ×¦×“ ×•×™×•×¨×” ×§×¨×Ÿ ××•×¨ ××”××¨×™×ª ×›×“×™
          <strong>×œ×”×©××™×“ ××•×ª× ×œ×¤× ×™ ×©×™×’×™×¢×• ×œ×¨×‘×¢ ×”×ª×—×ª×•×Ÿ</strong>. ××”×¨×’×¢ ×©×”× × ×›× ×¡×™× ×œ×¨×‘×¢ ×”×ª×—×ª×•×Ÿ â€“ ×”× ×—×¡×™× ×™× ×•× ×•×—×ª×™× ×¢×œ ×”×¤×©×˜×™×“×”.
        </p>
        <ul>
          <li>×”×–×–×ª ××•×¨×™: ×—×¦×™× â—€ â–¶</li>
          <li>×™×¨×™: ×¨×•×•×— (Space) â€“ ×§×¨×Ÿ ×–×¨×™×–×”, ×—×•×“×¨×ª ×¢×“ 5 ××˜×¨×•×ª</li>
          <li>××©×š ××©×—×§: <strong>40 ×©× ×™×•×ª</strong></li>
          <li>××˜×¨×”: ×œ×”×©××™×¨ ×›××” ×©×™×•×ª×¨ ××”×¤×©×˜×™×“×” × ×§×™×™×” ××œ×Ö¾×§×™×˜×• ×©× ×—×ª</li>
        </ul>
        <button class="btn" id="startBtn">××ª×—×™×œ×™×</button>
      </div>
    </div>
  </div>
<script>
// ===================== ×”×’×“×¨×•×ª ×‘×¡×™×¡ =====================
window.addEventListener('DOMContentLoaded', () => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  ctx.imageSmoothingEnabled = false;

  const STATE = { START: 0, PLAY: 1, OVER: 2 };
  let state = STATE.START;
  const hud = document.getElementById('hud');

  // --- ×§×‘×•×¢×™× (×§×œ ×™×•×ª×¨) ---
  const GAME_DURATION = 40;        // ×©× ×™×•×ª
  const CAS_RATIO     = 0.72;      // ×”×¤×©×˜×™×“×” × ××•×›×” ×™×•×ª×¨ â€“ ×™×•×ª×¨ ××¨×—×§ ×œ×™×¨×™
  const SAFE_QUARTER  = 0.82;      // ××–×•×¨ ×—×¡×™× ×•×ª × ××•×š ×™×•×ª×¨ â€“ ×™×•×ª×¨ ×–××Ÿ ×œ×¤×’×™×¢×”
  const FIRE_COOLDOWN = 90;        // ms (×™×¨×™ ××”×™×¨ ×™×•×ª×¨)
  const SPAWN_EVERY   = 950;       // ms (×¤×—×•×ª ×¢×•××¡)
  const MAX_PIERCE    = 5;         // ×”×§×¨×Ÿ ×—×•×“×¨×ª ×™×•×ª×¨ ××˜×¨×•×ª
  const DROP_MIN_SPD  = 1.6, DROP_MAX_SPD = 2.8; // × ×¤×™×œ×” ××™×˜×™×ª ×™×•×ª×¨

  // --- ×©×—×§×Ÿ ---
  const player = { x: canvas.width / 2 - 32, y: canvas.height - 96, w: 72, h: 88, speed: 7 };
  const playerImg = new Image();
  playerImg.src = 'https://i.postimg.cc/sfbHGQ1V/Chat-GPT-Image-Aug-14-2025-10-12-34-PM.png';

  function drawPlayer(px, py){
    if (playerImg.complete) { ctx.drawImage(playerImg, px, py, player.w, player.h); }
    else { ctx.fillStyle = '#3fbf8a'; ctx.fillRect(px, py, player.w, player.h); }
  }

  // --- ××˜×¨×•×ª: ×¨×§ ×œ×Ö¾×§×™×˜×•×’× ×™×™× ---
  const NON  = ['ğŸ','ğŸ¥','ğŸ¥–','ğŸ','ğŸ°','ğŸ©','ğŸ¥”','ğŸŸ','ğŸª','ğŸ•'];
  const drops = [];
  function spawnDrop(){
    const emoji = NON[Math.floor(Math.random()*NON.length)];
    const size  = 40 + Math.random()*18;
    drops.push({ x: Math.random()*(canvas.width - size), y: -size, size, vy: DROP_MIN_SPD + Math.random()*(DROP_MAX_SPD - DROP_MIN_SPD), emoji, landed:false, shielded:false });
  }

  // --- ×§×¨× ×™×™× ---
  const beams = []; let lastFire = 0;
  function fireBeam(){
    const now = performance.now();
    if(now - lastFire < FIRE_COOLDOWN) return;
    lastFire = now;
    const originX = player.x + player.w*0.28;
    const originY = player.y + player.h*0.35;
    beams.push({ x: originX, y: originY, w: 12, h: 20, vx: 0, vy: -16, life: 160, pierce: MAX_PIERCE });
  }

  // --- ×§×œ×˜ ---
  const keys = new Set();
  addEventListener('keydown', e=>{
    if([' ','Spacebar','ArrowLeft','ArrowRight','ArrowUp','ArrowDown'].includes(e.key)) e.preventDefault();
    if(e.key === ' ' || e.key === 'Spacebar'){ fireBeam(); }
    keys.add(e.key);
  });
  addEventListener('keyup',   e=>{ keys.delete(e.key); });

  // --- × ×™×§×•×“/×˜×™×™××¨ ---
  let score = 0, timeLeft = GAME_DURATION, totalSpawned = 0, landedBad = 0;
  let rafId = null, spawnInterval = null, timerInterval = null;

  function updateHud(){ hud.textContent = `× ×™×§×•×“: ${score} Â· ×–××Ÿ: ${timeLeft}`; }

  function startGame(){
    score=0; timeLeft=GAME_DURATION; totalSpawned=0; landedBad=0; drops.length=0; beams.length=0;
    player.x = canvas.width/2 - player.w/2; state = STATE.PLAY;
    spawnInterval = setInterval(()=>{ spawnDrop(); totalSpawned++; }, SPAWN_EVERY);
    timerInterval = setInterval(()=>{ timeLeft--; if(timeLeft<=0) endGame(); updateHud(); }, 1000);
    document.getElementById('startOverlay').style.display = 'none';
    loop(); updateHud();
  }

  function endGame(){
    state = STATE.OVER; clearInterval(spawnInterval); clearInterval(timerInterval); if(rafId) cancelAnimationFrame(rafId);
    const cleanPct = totalSpawned === 0 ? 100 : Math.max(0, 100 - Math.round((landedBad/Math.max(1,totalSpawned))*100));
    const verdict =
      cleanPct >= 90 ? "××ª×” ×’×™×‘×•×¨ ×¢×œ! ×”×¤×©×˜×™×“×” ×¨×§ ×§×¦×ª ×œ× ×§×™×˜×•×’× ×™×ª."
    : cleanPct >= 75 ? "×–×™×”××ª ××ª ×”×¤×©×˜×™×“×”, ××‘×œ ×¨×§ ×§×¦×ª. ××¤×©×¨ ×œ×¤×–×¨ ×¢×œ ×”×œ×—× ×”×–×” ×‘×™×™×§×•×Ÿ, ××œ ×ª×“××’."
    : cleanPct >= 50 ? "×”×¤×©×˜×™×“×” ×§×™×˜×•×’× ×™×ª ×›××• ×©×”×¤××™ ×©×§×¨×™×Ÿ ×’×•×¨×Ÿ ××›×™× ×” ×§×™×˜×•×’× ×™."
    : cleanPct >= 25 ? "××” ×–×”, ×¤×©×˜×™×“×ª ×œ×—×?? ×œ×’×¨×“×•×!"
                     : "×©×œ×—× ×• ××ª ×”×¤×©×˜×™×“×” ×œ×©×™××•×¨ ×‘××•×–×™××•×Ÿ ×”×©×•×× ×™×. ğŸ›ï¸";

    const card = document.querySelector('.card');
    card.querySelector('h1').textContent = '× ×’××¨ ×”×–××Ÿ!';
    card.querySelector('p').innerHTML = `× ×™×§×•×“: <b>${score}</b><br>×œ×Ö¾×§×™×˜×• ×©× ×—×ª×•: <b>${landedBad}</b> / ${totalSpawned}<br>` +
      `××—×•×– ×¤×©×˜×™×“×” × ×§×™×™×”: <b>${cleanPct}%</b><br>${verdict}`;
    card.querySelector('ul').style.display = 'none';
    document.getElementById('startBtn').textContent = '×©×—×§×• ×©×•×‘';
    document.getElementById('startOverlay').style.display = 'flex';
  }

  function rectsCollide(ax,ay,aw,ah,bx,by,bw,bh){ return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by; }

  // ===================== ×œ×•×œ××ª ×”××©×—×§ =====================
  function update(){
    if(state !== STATE.PLAY) return;
    if(keys.has('ArrowLeft'))  player.x -= player.speed;
    if(keys.has('ArrowRight')) player.x += player.speed;

    // ×™×¨×™ ×¨×¦×™×£ ×× ××—×–×™×§×™× ×¨×•×•×—
    if(keys.has(' ') || keys.has('Spacebar')) fireBeam();

    player.x = Math.max(0, Math.min(canvas.width - player.w, player.x));

    const casseroleY = canvas.height * CAS_RATIO;
    const shieldY    = canvas.height * SAFE_QUARTER;

    // × ×¤×™×œ×” ×•× ×—×™×ª×”
    for(let i=drops.length-1;i>=0;i--){
      const d = drops[i];
      if(!d.landed){
        d.y += d.vy;
        if(!d.shielded && d.y >= shieldY - d.size) d.shielded = true;
        if(d.y + d.size >= casseroleY){ d.y = casseroleY - d.size; d.landed = true; landedBad++; }
      }
    }

    // ×§×¨× ×™×™×
    for(let i=beams.length-1;i>=0;i--){
      const b = beams[i]; b.x += b.vx; b.y += b.vy; b.life--;
      for(let j=drops.length-1;j>=0;j--){
        const d = drops[j];
        if(!d.landed && !d.shielded && rectsCollide(b.x, b.y, b.w, b.h, d.x, d.y, d.size, d.size)){
          score += 2; drops.splice(j,1); if(--b.pierce <= 0){ beams.splice(i,1); } break;
        }
      }
      if(b.life<=0 || b.y < -40 || b.x < -40 || b.x > canvas.width+40){ beams.splice(i,1); }
    }
  }

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    const casseroleY = canvas.height*CAS_RATIO;
    ctx.strokeStyle = 'rgba(255,255,255,.15)'; ctx.beginPath(); ctx.moveTo(0, casseroleY); ctx.lineTo(canvas.width, casseroleY); ctx.stroke();
    const shieldY = canvas.height*SAFE_QUARTER;
    ctx.setLineDash([6,6]); ctx.strokeStyle = 'rgba(255,255,255,.10)'; ctx.beginPath(); ctx.moveTo(0, shieldY); ctx.lineTo(canvas.width, shieldY); ctx.stroke(); ctx.setLineDash([]);

    // ×©×—×§×Ÿ
    drawPlayer(player.x, player.y);

    // ×¤×¨×™×˜×™× â€“ ×¨×§×¢ ×¢×’×•×œ ××˜×•× + ×××•×’×³×™ ×‘×××¦×¢
    for(const d of drops){
      const cx = d.x + d.size/2, cy = d.y + d.size/2, r = d.size*0.6;
      ctx.fillStyle = '#ffffff'; ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.fill();
      ctx.font = `${d.size}px system-ui, 'Apple Color Emoji', 'Segoe UI Emoji'`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(d.emoji, cx, cy);
      if(d.shielded && !d.landed){ ctx.strokeStyle = 'rgba(255,216,0,.35)'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(cx, cy, r+4, 0, Math.PI*2); ctx.stroke(); ctx.lineWidth = 1; }
    }

    // ×§×¨× ×™×™×
    for(const b of beams){ ctx.fillStyle = '#ffe46b'; ctx.fillRect(b.x, b.y, b.w, b.h); ctx.fillStyle = '#fff4ab'; ctx.fillRect(b.x-2, b.y-2, b.w+4, b.h+4); }

    updateHud();
  }

  function loop(){ update(); draw(); rafId = requestAnimationFrame(loop); }

  // ===================== ××¡×›×™ ×¤×ª×™×—×”/×¡×™×•× =====================
  document.getElementById('startBtn').addEventListener('click', () => {
    const card = document.querySelector('.card');
    if(state === STATE.OVER){
      card.querySelector('h1').textContent = '××œ×š ×”×§×™×˜×•: ××¦×•×“ ×”×¤×©×˜×™×“×”';
      card.querySelector('p').innerHTML =
        '×¢×›×©×™×• ×–×” ××™×©×™: <strong>× ×•×¤×œ×™× ×¨×§ ×××›×œ×™× ×œ×Ö¾×§×™×˜×•×’× ×™×™×</strong>. ××•×¨×™ ×¨×¥ ××¦×“ ×œ×¦×“ ×•×™×•×¨×” ×§×¨×Ÿ ××•×¨ ××”××¨×™×ª ×›×“×™ <strong>×œ×”×©××™×“ ××•×ª× ×œ×¤× ×™ ×©×™×’×™×¢×• ×œ×¨×‘×¢ ×”×ª×—×ª×•×Ÿ</strong>. ××”×¨×’×¢ ×©×”× × ×›× ×¡×™× ×œ×¨×‘×¢ ×”×ª×—×ª×•×Ÿ â€“ ×—×¡×™× ×™× ×•× ×•×—×ª×™×.';
      card.querySelector('ul').style.display = '';
      document.getElementById('startBtn').textContent = '××ª×—×™×œ×™×';
    }
    startGame();
  });

  // × ×™×§×•×™ ××©××‘×™× ×× ×¡×•×’×¨×™× ×˜××‘
  window.addEventListener('beforeunload', ()=>{ clearInterval(spawnInterval); clearInterval(timerInterval); if(rafId) cancelAnimationFrame(rafId); });
});
</script>
</body>
</html>
